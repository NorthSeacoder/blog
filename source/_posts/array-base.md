---
title: 数组
date: 2021-05-08 09:36:01
comment: 'valine'
categories:
    - [算法, 基本数据结构]
tags:
    - 91
    - 算法
    - JS
    - array
    - 基础
---

# 数组

本章提到到数组仅指数据结构意义上的数组，而非编程语言中定义的数组

## 掌握程度

-   能自己实现动态数组,栈,队列

## 代码实现

-   实现一个支持动态扩容的数组
-   实现一个大小固定的有序数组,支持动态增删改操作
-   实现连个有序数组合并为一个有序数组

## 什么是数组

-   数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。
-   优点：两限制使得具有随机访问的特性
-   缺点：删除，插入数据效率低

线性表就是数据排成一条线一样的结构，每个线性表的数据最多只有前后两个方向。数组，链表，队列，栈 等都是线性表结构

在非线性表中，数据之间并不是简单的前后关系，二叉树，堆，图，等是非线性表

### 数组怎么根据下标随机访问的

-   通过寻址公式，计算出该元素存储的内存地址

```js
a[i]_address = base_address + i * data_type_size
```

### 为何数组插入和删除低效

-   若有一元素想往 int[n]的第 k 个位置插入/删除数据，需要在 k-n 的位置往后移/前移。最好情况时间复杂度 O(1),最坏情况复杂度为 O(n),平均负责度为 O(n)

#### 提高插入效率

-   如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第 k 个位置上的数据移到最后，然后将插入的数据直接放在第 k 个位置上。这样时间复杂度就将为 O（1）了。

#### 提高删除效率

-   将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。这也是 JVM 标记清除垃圾回收算法的核心思想。

### 为什么数组要从 0 开始编号

-   由于数组是通过寻址公式，计算出该元素存储的内存地址：

```js
a[i]_address = base_address + i * data_type_size
```

-   如果数组是从 1 开始计数，那么就会变成：

```js
a[i]_address = base_address + （i-1）* data_type_size
```

-   对于 CPU 来说，多了一次减法的指令。当然，还有一定的历史原因(c 语言最先采用从 0 开始编号，为了便于学习，其他语言继承了这一特点)

### 为什么数组要存储相同类型的值呢

相同的类型大小是固定且连续的(这里指的是基本类型，而不是引用类型，当然引用类型也可以存一个大小固定的指针，而将真实的内容放到别的地方，比如内存堆)，这样数组就可以随机访问了。试想数组第一项是 4 字节，第二项是 8 字节，第三项是 6 字节，我如何才能随机访问？而如果数组元素的大小都一样，我们就可以用基址 + 偏移量来定位任意一个元素，其中基值指的是数组的引用地址, 偏移量指的是数组的索引。

### 数组和链表的区别（数组）

-   数组中的元素存在一个连续的内存空间中，而链表中的元素可以不存在于连续的内存空间。
-   数组支持随机访问，根据下标随机访问的时间复杂度是 O(1)；链表适合插入、删除操作，时间复杂度为 O(1）。

## 数组的常见操作及对应时间复杂度

-   随机访问 -> O(1)
-   根据索引修改 -> O(1)
-   遍历数组 -> O(N)
-   插入数值到数组 -> O(N)
-   插入数值到数组最后 -> O(1)
-   从数组删除数值 -> O(N)
-   从数组最后删除数值 -> O(1)

## 相关问题

-   实现两个有序数组合并为一个有序数组
-   实现 strStr()
-   颜色分类
-   常数时间插入、删除和获取随机元素
-   螺旋矩阵 II
-   亲密字符串
