---
title: 链表
comment: valine
categories:
    - - 算法
      - 基本数据结构
tags:
    - 91
    - 算法
    - JS
    - 基础
    - 链表
date: 2021-05-16 13:37:56
---

# 链表

## 掌握程度

-   轻松写出经典链表题目
    -   链表翻转
    -   求中间节点

## 代码实现

-   实现单链表,循环链表,双向链表,支持增删操作
-   实现单链表翻转
-   实现两个有序的链表合并为一个有序的链表
-   求链表中间节点

## 什么是链表？

-   和数组一样，链表也是一种线性表。
-   从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。
-   链表中的每一个内存块被称为节点 Node。节点除了存储数据外，还需记录链上下一个节点的地址，即后继指针 next。

## 链表的特点

-   插入、删除数据效率高 O(1)级别（只需更改指针指向即可），随机访问效率低 O(n)级别（需要从链头至链尾进行遍历）。
-   和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

## 常用链表

### 单链表

-   每个节点只包含一个指针，即后继指针。
-   单链表有两个特殊的节点，即首节点和尾节点。用首节点地址表示整条链表，尾节点的后继指针指向空地址 null。
-   性能特点：插入和删除节点的时间复杂度为 O（1），查找的时间复杂度为 O(n)。

### 循环链表

-   除了尾节点的后继指针指向首节点的地址外均与单链表一致。
-   适用于存储有循环特点的数据，比如约瑟夫问题。

### 双向链表

-   节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针 prev）和下一个节点地址（后继指针 next）。
-   首节点的前驱指针 prev 和尾节点的后继指针均指向空地址。
-   性能特点：
    -   和单链表相比，存储相同的数据，需要消耗更多的存储空间。
    -   插入、删除操作比单链表效率更高 O(1)级别

### 双向循环链表

-   首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。

## 数组和链表的区别

-   插入、删除和随机访问的时间复杂度

    -   数组：插入、删除的时间复杂度是 O(n)，随机访问的时间复杂度是 O(1)。
    -   链表：插入、删除的时间复杂度是 O(1)，随机访问的时间复杂端是 O(n)。

-   数组缺点
    -   若申请内存空间很大，比如 100M，但若内存空间没有 100M 的连续空间时，则会申请失败，尽管内存可用空间超过 100M。
    -   大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。
-   链表缺点
    -   内存空间消耗更大，因为需要额外的空间存储指针信息。
    -   对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，还可能会造成频繁的 GC（自动垃圾回收器）操作。
-   如何选择
    数组简单易用，在实现上使用连续的内存空间，可以借助 CPU 的缓存机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法预读。
    如果代码对内存的使用非常苛刻，那数组就更适合。

## 缓存策略

-   先进先出策略 FIFO(First In，First Out)

-   最少使用策略 LFU（Least Frequently Used）

-   最近最少使用策略 LRU（Least Recently Used)

## 链表代码注意事项

### 理解指针或引用的含义

-   将某个变量（对象）赋值给指针（引用），实际上就是就是将这个变量（对象）的地址赋值给指针（引用）。

### 警惕指针丢失和内存泄漏（单链表）

-   插入节点

```js
//在节点a和节点b之间插入节点x，b是a的下一节点，，p指针指向节点a，则造成指针丢失和内存泄漏
p—>next = x
x—>next = p—>next
//显然这会导致x节点的后继指针指向自身。
//正确写法
x—>next = p—>next
p—>next = x;
```

-   删除节点

```js

//在节点a和节点b之间删除节点b，b是a的下一节点，p指针指向节点a
p—>next = p—>next—>next;

```

### 利用“哨兵”简化实现难度

-   什么是“哨兵”
    链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head 指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。
    本章均为带头链表
-   哨兵的优势
    “哨兵”节点不存储数据，无论链表是否为空，head 指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。

### 重点留意边界条件处理

经常用来检查链表是否正确的边界 4 个边界条件：

1. 如果链表为空时，代码是否能正常工作？
2. 如果链表只包含一个节点时，代码是否能正常工作？
3. 如果链表只包含两个节点时，代码是否能正常工作？
4. 代码逻辑在处理头尾节点时是否能正常工作？

## 常见题型及套路模板

### 翻转链表

-   将某个链表进行反转
-   在 O(n) 时间, O(1) 空间复杂度下逆序读取链表的某个值
-   将某个链表按 K 个一组进行反转

<details>
    <summary>展开查看</summary>

```js
let cur = head;
let pre = null;
while (cur) {
    const next = cur.next;
    cur.next = pre;
    pre = cur;
    cur = next;
}
return pre;
```

-   复杂度分析

    -   时间复杂度：O(N)
    -   空间复杂度：O(1)

</details>

### 合并链表

-   将两条有序或无序的链表合并成一条有序链表
-   将 k 条有序链表合并成一条有序链表

<details>
    <summary>展开查看</summary>

```js
//两个链表按顺序合并
let ans = (now = new ListNode(0));
while (l1 !== null && l2 !== null) {
    if (l1.val < l2.val) {
        now.next = l1;
        l1 = l1.next;
    } else {
        now.next = l2;
        l2 = l2.next;
    }
    now = now.next;
}

if (l1 === null) {
    now.next = l2;
} else {
    now.next = l1;
}
return ans.next;
```

时间复杂度：O(N)
空间复杂度：O(1)

</details>

### 相交或环形链表

-   判断某条链表是否存在环
-   获取某条链表环的大小
-   获取某两条链表的相交节点

#### 相交

<details>
    <summary>解法一:哈希法</summary>
    
- 有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。
- 遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点

```js
let data = new Set();
while (A !== null) {
    data.add(A);
    A = A.next;
}
while (B !== null) {
    if (data.has(B)) return B;
    B = B.next;
}
return null;
```

时间复杂度：O(N)
空间复杂度：O(N)

</details>

<details>
    <summary>解法二:双指针</summary>

-   使用 a, b 两个指针分别指向 A, B 这两条链表, 两个指针相同的速度向后移动,
-   当 a 到达链表的尾部时,重定位到链表 B 的头结点
-   当 b 到达链表的尾部时,重定位到链表 A 的头结点。
-   a, b 指针相遇的点为相交的起始节点，否则没有相交点

-   原理:

1. 将两条链表按相交的节点截断为 3 份，链表 1 为: A + C，链表 2 为: B + C
2. 当 a 指针将链表 1 遍历完后,重定位到链表 B 的头结点,然后继续遍历直至相交点(a 指针遍历的距离为 A + C + B)
3. 同理 b 指针遍历的距离为 B + C + A

```js
var getIntersectionNode = function (headA, headB) {
    let a = headA,
        b = headB;
    while (a != b) {
        a = a === null ? headB : a.next;
        b = b === null ? headA : b.next;
    }
    return a;
};
```
时间复杂度：O(N)
空间复杂度：O(1)
</details>

#### 环形链表求环的起点

<details>
    <summary>解法一:哈希法</summary>

```js

```

</details>

<details>
    <summary>解法一:哈希法</summary>

```js

```

</details>