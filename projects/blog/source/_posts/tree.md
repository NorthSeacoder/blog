---
title: 树
comment: valine
categories:
    - - 算法
      - 基本数据结构
tags:
    - 91
    - 算法
    - JS
    - 基础
date: 2021-05-22 11:27:53
---

# 树

## 掌握程度

-   二叉树
    -   能代码实现二叉树的三种遍历算法,按层遍历,求高度等经典二叉树题目

## 代码实现

-   实现一个二叉查找树,支持插入,删除,查找操作
-   实现查找二叉树中某个节点的后继,前驱结点
-   实现二叉树前中后序及层次遍历

## 常用概念

-   节点:树中的每个元素称为节点
-   父子关系:相邻节点的连线
-   根节点:没有父节点的节点
-   叶子节点:没有子节点的节点
-   兄弟节点:具有相同父节点的多个节点
-   节点高度:节点到叶子节点的最长路径包含的边数
-   深度:根节点到节点的路径所包含的边数
-   层数:节点的深度+1
-   树的高度:根节点的高度/任一节点深度+高度

## 二叉树

### 概念

-   二叉树:每个节点最多只有两个子节点的树
-   满二叉树:除了叶子节点,每个节点都有左右两个子节点的二叉树
-   完全二叉树:叶子节点都在最下两层,最后一层叶子节点都为左节点,且除了最后一层其它层为满二叉树

### 存储

#### 链式存储

-   每个节点由三个字段组成,数据以及分别指向左右子节点的指针

#### 数组存储

-   根节点存储在下标为 1 的位置,左子节点为 2,右子节点为 3,即,节点下标为 i,其左子节点下标为 2i,右子节点下标为 2i+1,父节点为 i/2

### 遍历

#### 前序遍历

-   先遍历本身,再遍历左子树,最后遍历右子树
-   递推公式

```js
function preorder(root) {
    if (!root) return;
    doSomething(root);
    preorder(root.left);
    preorder(root.right);
}
```

#### 中序遍历

-   先遍历左子树,再遍历本身,最后遍历右子树
-   递推公式

```js
function inorder(root) {
    if (!root) return;
    inorder(root.left);
    doSomething(root);
    inorder(root.right);
}
```

-   实现

#### 后序遍历

-   先遍历左子树,再遍历右子树,最后是本身
-   递推公式

```js
function postorder(root) {
    if (!root) return;
    postorder(root.left);
    postorder(root.right);
    dosomething(root);
}
```

#### 层序遍历(BFS)

-   层次遍历从直观上会先遍历树的第一层， 再遍历树的第二层，以此类推。

```js
bfs(root) {
 queue = []
 queue.push(root)
 while queue.length {
  curLevel = queue
  queue = []
  for i = 0 to curLevel.length {
   doSomething(curLevel[i])
   if (curLevel[i].left) {
    queue.push(curLevel[i].left)
   }
   if (curLevel[i].right) {
    queue.push(curLevel[i].right)
   }
  }
 }
}
```

#### 时间复杂度

-   每个节点的最多被访问两次,故时间复杂度是 O(n)

## 二叉搜索树

### 概念

树中的任意一个节点,其左子树中的每个节点的值都小于这个节点的值,而右子树节点的值都大于这个节点的值

### 特点

支持动态数据集合的快速插入,删除,查找操作

### 操作

-   查找

-   插入

-   删除

-   查找最大节点和最小节点

-   查找前驱结点和后继节点

## 红黑树

### 概念

-   根节点是黑色的
-   每个叶子节点都是黑色的空节点(叶子节点不存储数据)
-   任何相邻的节点都不能同为红色(指同一路径上的节点)
-   每个节点,从该节点到达其可达叶子节点的所有路径,都包含相同的黑色节点

#### 演变

-   起源为二叉查找树,但容易退化为链表
-   产生 2-3 树
    -   定义:
        -   二叉查找树的变种,有 2-,3-两种节点
        -   2-节点为普通节点,即包含一个元素,两条子连接
        -   3-节点是包含 2 个元素和 3 条连接
    -   构造
        -   值插入 2-节点,2-节点扩充为 3-节点
        -   插入 3-节点
            -   该节点为根节点,将其扩充为 4-节点,然后分解为一课二叉树
            -   3-节点有一个 2-节点的父节点,将其扩充为 4-节点,然后分解,将新树的父节点融入原父节点生成 3-节点
            -   3-节点有一个 3-父节点,3-节点扩充为 4-节点,分解,新树节点融入原父节点变成 4-节点,父节点分解,行程新的二叉树,如果父节点为根节点,则再加一层
    -   优点:保持平衡,性能良好
    -   缺点:代码复杂,处理情况多,同时维护两种不同的节点
-   产生红黑树
    -   红黑树中,所有节点都是 2-节点,为了体现出 3-节点,将 3-节点的两个元素用左斜红斜线连接,即连接了两个 2-节点来表示一个 3-节点
    -   该红色斜线指向的节点为红色节点

## 树总结(lucifer)

### 一个中心

-   树的遍历:迭代/递归分别实现

### 两个基本点

#### 深度优先遍历(DFS)

##### 算法流程

1. 首先将根节点放入 **stack** 中。
2. 从 stack 中取出第一个节点，并检验它是否为目标。如果找到所有的节点，则结束搜寻并回传结果。否则将它某一个尚未检验过的直接子节点加入 stack 中。
3. 重复步骤 2。
4. 如果不存在未检测过的直接子节点。将上一级节点加入 stack 中。 重复步骤 2。
5. 重复步骤 4。
6. 若 stack 为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。

**这里的 stack 可以理解为自己实现的栈，也可以理解为调用栈。如果是调用栈的时候就是递归，如果是自己实现的栈的话就是迭代。**

##### 算法模板

<details>
    <summary>基础模板</summary>

```js
const visited = {}
function dfs(i) {
 if (满足特定条件）{
  // 返回结果 or 退出搜索空间
 }

 visited[i] = true // 将当前状态标为已搜索
 for (根据i能到达的下个状态j) {
  if (!visited[j]) { // 如果状态j没有被搜索过
   dfs(j)
  }
 }
}
```

</details>

<details>
    <summary>常见二叉树模板</summary>

```js
function dfs(root) {
 if (满足特定条件）{
  // 返回结果 or 退出搜索空间
 }
    main()//前序遍历
    dfs(root.left)
    dfs(root.right)
    main()//后序遍历
    //中序遍历一般用于平衡二叉树
}
```

</details>

#### 广度优先遍历(BFS)

-   BFS 比较适合找最短距离/路径和某一个距离的目标

##### 算法流程

1. 将根节点放入**队列**中
2. 从队列中取出第一个节点，并检验它是否为目标。

    - 如果找到目标，则结束搜索并回传结果。
    - 否则将它所有尚未检验过的直接子节点加入队列中。

3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。
4. 重复步骤 2。

##### 算法模板

<details>
    <summary>基础模板</summary>

```js
const visited = {}
function bfs() {
 let q = new Queue()
 q.push(初始状态)
 while(q.length) {
  let i = q.pop()
        if (visited[i]) continue
        if (i 是我们要找的目标) return 结果
  for (i的可抵达状态j) {
   if (j 合法) {
    q.push(j)
   }
  }
    }
    return 没找到
}
```

</details>

### 三种题型

-   搜索类，构建类和修改类

#### 搜索类

-   把握三个核心点，即开始点，结束点 和 目标即可。

##### dfs 搜索

##### bfs 搜索

#### 构建类

##### 普通二叉树

##### 二叉搜索树

#### 修改类

### 四个概念

-   二叉搜索树
-   完全二叉树'
-   路径
-   距离

### 七个技巧

-   基于 dfs 的，bfs 掌握了模板就行，基本没有什么技巧可言。

1. dfs(root)
2. 单双递归
3. 前后遍历:如果是前序遍历，那么你可以想象上面的节点都处理好了，怎么处理的不用管。相应地如果是后序遍历，那么你可以想象下面的树都处理好了，怎么处理的不用管
4. 虚拟节点
